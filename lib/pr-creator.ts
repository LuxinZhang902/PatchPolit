import { DebugSession } from '@/types';
import { prisma } from './prisma';
import * as path from 'path';
import * as fs from 'fs/promises';
import { Octokit } from '@octokit/rest';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Creates a pull request for a completed session
 */
export async function createPullRequestForSession(session: DebugSession): Promise<void> {
  const backendBaseUrl = process.env.BACKEND_BASE_URL || 'http://localhost:3000';
  const workspaceDir = path.join(process.cwd(), 'sandbox', 'temp', session.id);

  try {
    // Update session to show PR creation in progress
    await prisma.debugSession.update({
      where: { id: session.id },
      data: {
        logs: (session.logs || '') + `[${new Date().toISOString()}] Creating pull request...\n`,
      },
    });

    const repoDir = path.join(workspaceDir, 'repo');
    const githubToken = process.env.GITHUB_TOKEN;

    // Extract owner and repo from URL
    const repoMatch = session.repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!repoMatch) {
      throw new Error('Invalid GitHub repository URL');
    }
    const [, owner, repoName] = repoMatch;
    const repo = repoName.replace(/\.git$/, '');

    if (githubToken) {
      // Real PR creation with GitHub API
      try {
        await prisma.debugSession.update({
          where: { id: session.id },
          data: {
            logs: (session.logs || '') + `[${new Date().toISOString()}] Pushing branch to GitHub...\n`,
          },
        });

        // Push the branch to GitHub
        await execAsync(`git push origin patchpilot-fix`, { cwd: repoDir });

        await prisma.debugSession.update({
          where: { id: session.id },
          data: {
            logs: (session.logs || '') + `[${new Date().toISOString()}] Creating pull request via GitHub API...\n`,
          },
        });

        // Create PR using Octokit
        const octokit = new Octokit({ auth: githubToken });
        
        const prBody = `## ü§ñ AI-Generated Bug Fix

**Bug Description:**
${session.bugDescription}

**Changes Made:**
This PR contains an AI-generated patch that addresses the issue described above.

**Test Command:**
\`\`\`bash
${session.reproCommand}
\`\`\`

${session.skipTests ? '‚ö†Ô∏è **Note:** Tests were skipped during patch generation.' : '‚úÖ **Tests passed** after applying this patch.'}

---
*Generated by PatchPilot - AI-powered bug fixing*`;

        const pr = await octokit.pulls.create({
          owner,
          repo,
          title: `fix: ${session.bugDescription.substring(0, 72)}`,
          head: 'patchpilot-fix',
          base: session.branch,
          body: prBody,
        });

        const prUrl = pr.data.html_url;

        await prisma.debugSession.update({
          where: { id: session.id },
          data: {
            prUrl,
            logs: (session.logs || '') + 
              `[${new Date().toISOString()}] ‚úÖ Pull request created successfully!\n` +
              `[${new Date().toISOString()}] PR #${pr.data.number}: ${prUrl}\n`,
          },
        });

      } catch (error: any) {
        // If push/PR creation fails, fall back to compare URL
        const compareUrl = `${session.repoUrl}/compare/${session.branch}...patchpilot-fix`;
        
        await prisma.debugSession.update({
          where: { id: session.id },
          data: {
            prUrl: compareUrl,
            logs: (session.logs || '') + 
              `[${new Date().toISOString()}] ‚ö†Ô∏è Failed to create PR: ${error.message}\n` +
              `[${new Date().toISOString()}] This might be because:\n` +
              `[${new Date().toISOString()}]   - You don't have write access to the repository\n` +
              `[${new Date().toISOString()}]   - The branch already exists on GitHub\n` +
              `[${new Date().toISOString()}]   - The GitHub token doesn't have sufficient permissions\n` +
              `[${new Date().toISOString()}] Compare URL: ${compareUrl}\n`,
          },
        });
      }
    } else {
      // No GitHub token - provide instructions
      const compareUrl = `${session.repoUrl}/compare/${session.branch}...patchpilot-fix`;
      
      await prisma.debugSession.update({
        where: { id: session.id },
        data: {
          prUrl: compareUrl,
          logs: (session.logs || '') + 
            `[${new Date().toISOString()}] ‚ö†Ô∏è GITHUB_TOKEN not configured\n` +
            `[${new Date().toISOString()}] To enable automatic PR creation:\n` +
            `[${new Date().toISOString()}]   1. Create a GitHub Personal Access Token with 'repo' scope\n` +
            `[${new Date().toISOString()}]   2. Add GITHUB_TOKEN=your_token to your .env file\n` +
            `[${new Date().toISOString()}]   3. Restart the application\n` +
            `[${new Date().toISOString()}] \n` +
            `[${new Date().toISOString()}] For now, you can manually create a PR:\n` +
            `[${new Date().toISOString()}]   1. cd ${repoDir}\n` +
            `[${new Date().toISOString()}]   2. git push origin patchpilot-fix\n` +
            `[${new Date().toISOString()}]   3. Visit: ${compareUrl}\n`,
        },
      });
    }

    // Clean up workspace (optional)
    try {
      await fs.rm(workspaceDir, { recursive: true, force: true });
    } catch (error) {
      console.error('Failed to clean up workspace:', error);
    }
  } catch (error) {
    console.error('Error creating PR:', error);
    
    // Update session with error
    await prisma.debugSession.update({
      where: { id: session.id },
      data: {
        logs: (session.logs || '') + 
          `[${new Date().toISOString()}] ‚úó Failed to create pull request: ${error}\n`,
      },
    });

    throw error;
  }
}
